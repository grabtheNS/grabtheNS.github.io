<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在OpenFOAM中构建SE双方程模型</title>
    <link href="/2024/10/07/%E5%9C%A8OpenFOAM%E4%B8%AD%E6%9E%84%E5%BB%BASE%E5%8F%8C%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/10/07/%E5%9C%A8OpenFOAM%E4%B8%AD%E6%9E%84%E5%BB%BASE%E5%8F%8C%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="SE双方程模型"><a href="#SE双方程模型" class="headerlink" title="SE双方程模型"></a>SE双方程模型</h1><p>SE双方程模型=单分布模型，它是一种简化的模型假设，假定碳烟的粒径分布为单分布。具体的模型假定可以参考<a href="https://ignite.byu.edu/sootlib_documentation/md_models_2_mono.html">SootLib: Monodispersed (byu.edu)</a>。</p><p>值得说明的是，目前的SootLib仍然有很多的BUG，目前通过我的测试的搭配：</p><p>SootModelSelect<br>{<br>    nucleationModel   LL;<br>    growthModel       LL;<br>    oxidationModel    OPTG;<br>    coagulationModel  NONE;<br>}</p><h1 id="具体实现耦合框架"><a href="#具体实现耦合框架" class="headerlink" title="具体实现耦合框架"></a>具体实现耦合框架</h1><h2 id="输运方程"><a href="#输运方程" class="headerlink" title="输运方程"></a>输运方程</h2><p>在OpenFOAM中，求解数密度矩的输运方程：</p><p> <code>fvScalarMatrix MOM0Eqn</code></p><p>​      <code>(</code>       </p><p>​        <code>fvm::ddt(rho , M0) +fvm::div(phi, M0 )  \+ fvm::div(phiTh, M0)// 添加热泳项</code> </p><p>​        <code>==</code> </p><p>​        <code>fvm::laplacian(diffusionCoeff * rhoGas , M0 ) + SM0</code> </p><p>​      <code>);</code></p><p>​      <code>fvScalarMatrix MOM1Eqn</code></p><p>​      <code>(</code></p><p>​        <code>fvm::ddt(rho , M1)  +fvm::div(phi, M1)  \+ fvm::div(phiTh, M1)   // 添加热泳项</code></p><p>​        <code>==</code></p><p>​        <code>fvm::laplacian( diffusionCoeff * rhoGas, M1 )  +SM1</code> </p><p>​      <code>);</code></p><p>其中第一项是时间导数项，第二项是对流项，第三项是热泳项，第四项是扩散项，第五项是源项<br>其中，相关文献提到扩散项可以忽略不计，而热泳项在AMREX中并未考虑。具体的建模公式可以参考文献。</p><p>这里我是直接进行求解，有文献（NGA求解器）采用分裂算子的方法进行计算。</p><p>源项的计算：</p><p>​      <code>std::vector&lt;double&gt; yGas&#123;Y_H[cellI], Y_H2[cellI], Y_O[cellI], Y_O2[cellI], Y_OH[cellI],Y_H2O[cellI],Y_CO[cellI], Y_C2H2[cellI] &#125;;</code></p><p>​      <code>std::vector&lt;double&gt; Msoot&#123;M0[cellI]* rhoGas[cellI] , M1[cellI]* rhoGas[cellI]  , M2[cellI]* rhoGas[cellI], M3[cellI]* rhoGas[cellI]&#125;;           // soot moment values [M0, M1, M2, M3]</code></p><p>​      <code>S.setState(T[cellI], p[cellI], rhoGas[cellI], muGas[cellI], yGas, yPAH, Msoot, nsoot );</code></p><p>这里大致的求解步骤：<br>给一个小的M1 M0初值，然后与其它所需化学物质温度等变量作为输入进行矩的源项计算，然后进行矩的输运方程计算。</p><h2 id="耦合物种消耗"><a href="#耦合物种消耗" class="headerlink" title="耦合物种消耗"></a>耦合物种消耗</h2><p>考虑碳烟带来的物质消耗，以02为例<br><code>if (Yi.name() == &quot;O2&quot;) &#123;</code></p><p>​        <code>YiEqn -= O2ConsumptionRate;</code></p><p>在物种的输运方程添加一个源项。</p><h2 id="修正质量守恒方程"><a href="#修正质量守恒方程" class="headerlink" title="修正质量守恒方程"></a>修正质量守恒方程</h2><p>同时也要考虑碳烟带来的气相质量损失，修改连续性方程  fvScalarMatrix rhoEqn</p><p>  <code>(</code></p><p>​    <code>fvm::ddt(rho)</code></p><p>   <code>\+ fvc::div(phi)</code></p><p>   <code>==</code></p><p>   <code>totalConsumptionRate</code></p><p>  <code>);</code><br>其中，totalConsumptionRate为所有化学物质的总消耗</p><h2 id="修正过氧化和非物理结果"><a href="#修正过氧化和非物理结果" class="headerlink" title="修正过氧化和非物理结果"></a>修正过氧化和非物理结果</h2><p>​      <code>forAll(mesh.cells(), cellI)</code></p><p>​      <code>&#123;</code></p><p>​        <code>if( M0[cellI] &lt; smallWeight || M1[cellI] &lt; tolV )</code></p><p>​        <code>&#123;</code></p><p>​          <code>M1[cellI] = std::max(M1[cellI] , tolV);</code></p><p>​          <code>M0[cellI] = M1[cellI] /nuclVol ;</code></p><p>​          <code>Info &lt;&lt; &quot;modify in &quot; &lt;&lt; cellI&lt;&lt;endl;</code></p><p>​        <code>&#125;</code></p><p>​        <code>sootfv[cellI] = M1[cellI] * rho[cellI] /1850  ; //计算碳烟体积分数</code></p><p>​      <code>&#125;</code></p><p>在结束计算后，由于实际物理意义中矩不可能有负数，而计算过程中由于过氧化带来的负数矩要进行修正，用一个较小的数字进行替代。</p><h2 id="碳烟ppm转化公式"><a href="#碳烟ppm转化公式" class="headerlink" title="碳烟ppm转化公式"></a>碳烟ppm转化公式</h2><p>求得的M1还不是我们常用的碳烟体积分数，假定碳烟的密度为1850g/cm^3<br>sootfv[cellI] = M1[cellI] * rho[cellI] /1850</p><h2 id="压力边界条件设置"><a href="#压力边界条件设置" class="headerlink" title="压力边界条件设置"></a>压力边界条件设置</h2><p>不要设置fixValue边界条件，这样改变燃烧室的压力时候会计算报错。正确的压力边界条件设置：</p><p>dimensions      [1 -1 -2 0 0 0 0];</p><p>internalField   uniform  201325;</p><p>boundaryField<br>{<br>    inletfuel<br>    {<br>     type            zeroGradient;<br>    }<br>    inletair<br>    {<br>     type            zeroGradient;<br>    }<br>    outlet<br>    {<br>     type            zeroGradient;<br>    }<br>    axis<br>    {<br>        type            empty;<br>    }<br>    leftside<br>    {<br>     type            zeroGradient;<br>    }<br>    burnerwall<br>    {<br>     type            zeroGradient;<br>    }<br>    front<br>    {<br>        type            wedge;<br>    }<br>    back<br>    {<br>        type            wedge;<br>    }<br>}</p><h2 id="光学薄膜假设辐射项"><a href="#光学薄膜假设辐射项" class="headerlink" title="光学薄膜假设辐射项"></a>光学薄膜假设辐射项</h2><p>理论基础：</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>碳烟的HACA机理以及在AMREX中的实现</title>
    <link href="/2024/10/06/%E7%A2%B3%E7%83%9F%E7%9A%84HACA%E6%9C%BA%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9C%A8AMREX%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <url>/2024/10/06/%E7%A2%B3%E7%83%9F%E7%9A%84HACA%E6%9C%BA%E7%90%86%E4%BB%A5%E5%8F%8A%E5%9C%A8AMREX%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HACA原理"><a href="#HACA原理" class="headerlink" title="HACA原理"></a>HACA原理</h1><p>参考<a href="https://ignite.byu.edu/sootlib_documentation/md_models_1_chemistry.html">SootLib: Chemistry and Physical Models (byu.edu)</a>HACA机理由下面六个反应构成</p><div class="table-container"><table><thead><tr><th></th><th style="text-align:left">Reaction</th><th style="text-align:left">Rate constant</th></tr></thead><tbody><tr><td>(1)</td><td style="text-align:left">C(s)-H + H ↔ C(s) . + H 2</td><td style="text-align:left">k1=4.2×1013e−13/RT</td></tr><tr><td></td><td style="text-align:left"></td><td style="text-align:left">kr1=3.9×1012e−11/RT</td></tr><tr><td>(2)</td><td style="text-align:left">C(s)-H + OH ↔ C(s) . + H 2O</td><td style="text-align:left">k2=1.0×1010T0.734e−1.43/RT</td></tr><tr><td></td><td style="text-align:left"></td><td style="text-align:left">kr2=3.68×108T1.139e−17.1/RT</td></tr><tr><td>(3)</td><td style="text-align:left">C(s) . + H → C(s)-H</td><td style="text-align:left">k3=2.0×1013</td></tr><tr><td>(4)</td><td style="text-align:left">C(s) . + C 2H 2 → C(s)-H + H</td><td style="text-align:left">k4=8.0×107T1.56e−3.8/RT</td></tr><tr><td>(5)</td><td style="text-align:left">C(s) . + O 2 → 2CO + products</td><td style="text-align:left">k5=2.2×1012e−7.5/RT</td></tr><tr><td>(6)</td><td style="text-align:left">C(s)-H + OH → CO + products</td><td style="text-align:left">k6=0.13⋅1290T−1/2</td></tr></tbody></table></div><p>（1）-（4）代表碳烟的表面增长，（5）（6）代表氧化</p><p>其中值得注意的是：反应（1）-（5）需要进行稳态自由基点位数密度的计算</p><p>碳烟自由基点位由以下公式进行计算：</p><script type="math/tex; mode=display">\chi_{C^{-}}=\left[\frac{k_1[\mathrm{H}]+k_2[\mathrm{OH}]}{k_{r 1}\left[\mathrm{H}_2\right]+k_{r 2}\left[\mathrm{H}_2 \mathrm{O}\right]+k_3[\mathrm{H}]+k_4\left[\mathrm{C}_2 \mathrm{H}_2\right]+k_5\left[\mathrm{O}_2\right]}\right] \chi_{C-H},</script><p>其中C-H表面点位被假定为</p><script type="math/tex; mode=display">\chi_{C-H}=2.3 \times 10^{15} \text { sites } \backslash m^2</script><p>而剩下的k则是相关的化学反应速率常数，r代表逆反应。一旦碳烟自由基表面反应点位被计算，碳烟的生长速率可以这样表示</p><script type="math/tex; mode=display">R_{g r w}=k_4 \chi_C \cdot\left[\mathrm{C}_2 \mathrm{H}_2\right]</script><p>碳烟被O2和OH氧化的速率表示为：</p><script type="math/tex; mode=display">\begin{gathered}R_{o x i}=k_5 \chi_C \cdot\left[\mathrm{O}_2\right] \\R_{o x i}=k_6 \chi_{C-H} P_{O H}\end{gathered}</script><h1 id="AMREX中的代码功能的实现"><a href="#AMREX中的代码功能的实现" class="headerlink" title="AMREX中的代码功能的实现"></a>AMREX中的代码功能的实现</h1><p>先吐槽一句，PELELMX中的代码，可能是我的代码水平太低，总感觉可读性太差！！<br>阿伦尼乌斯方程形式：</p><script type="math/tex; mode=display">k(T)=A \cdot T^n \cdot e^{-E_a /(R \cdot T)}</script><p>其中A是频率因子，T是温度，n是温度指数，Ea是活化能，R是气体常数</p><p>在PELE中，</p><p>A_f和A_b分别是正向和逆向反应的频率因子<br>n_f和n_b分别是正向和逆向的温度指数<br>ER_f和ER_b分别是正向和反向反应的活化能，这里ER代表活化能除以气体常数的值</p><p>PELE使用的是CGS（厘米-克-秒）单位，注意的是这里和sootlib对应不上是因为单位的原因</p><p><code>static constexpr amrex::Real RU = 8.31446261815324e7;</code></p><p> <code>static constexpr amrex::Real Avna = 6.022140857e23;</code><br>此处的RU是标准常数</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HMOM方法原理</title>
    <link href="/2024/10/06/HMOM%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86/"/>
    <url>/2024/10/06/HMOM%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Copy</p><h1 id="HMOM方法原理"><a href="#HMOM方法原理" class="headerlink" title="HMOM方法原理"></a>HMOM方法原理</h1><p>HMOM(Hybrid Method of Moments)是一种结合了MOMIC和DQMOM两种方法的矩方法<br>MOMIC:在数值上很容易实现但是不能解释碳烟的双模分布<br>DQMOM：是精确的，但是数值上很难实现</p><h2 id="MOMIC"><a href="#MOMIC" class="headerlink" title="MOMIC"></a>MOMIC</h2><p>采用Muller等人的体积-表面积（VS)对碳烟颗粒进行描述<br>碳烟直径可表述为：</p><script type="math/tex; mode=display">d_p=6 V S^ { -1 }</script><p>碳烟数密度可表述为：</p><script type="math/tex; mode=display">n_p=\frac{1}{36 \pi} V^{-2} S^3</script><p>所以对于一个双变量描述的碳烟来说，NDF的矩有两个指标（一个是体积，一个是表面积）。</p><script type="math/tex; mode=display">M_{x, y}=\sum_i V_i^x S_i^y N_i</script><p>i是对二维空间上的求和</p><p>另外一个原始版本的矩的定义可以供参考</p><script type="math/tex; mode=display">M_r=\int_0^{\infty} m^r n(m) d m</script><p>在MOMIC中，输运方程求解一组矩，然后源项用对数多项式进行已知矩的插值</p><p>剩下内容目前还看不懂，先留着！！！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>linux系统常用指令</title>
    <link href="/2024/10/05/linux%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/"/>
    <url>/2024/10/05/linux%E7%B3%BB%E7%BB%9F%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-linux系统常用指令"><a href="#title-linux系统常用指令" class="headerlink" title="title: linux系统常用指令"></a>title: linux系统常用指令</h2><p><code>find . -name &#39;*&#39; | xargs grep -1 Spark</code>     </p><p>寻找当前文件里面带有Spark关键词的文件</p><p><code>find $WM_PROJECT_DIR -name probesDi</code><br>查找文件名</p><p><code>find . -name &quot;*:Zone.Identifier&quot; -type f -delete</code><br>清除.Zone文件</p><h1 id="github相关"><a href="#github相关" class="headerlink" title="github相关"></a>github相关</h1><p><code>git pull origin development</code>  更新已经拉取的</p><p><code>git clone --recursive URL</code>   连通子模块一起拉取</p><h1 id="python相关"><a href="#python相关" class="headerlink" title="python相关"></a>python相关</h1><p><code>conda deactivate</code> 退出当前环境</p><p><code>conda activate deepflame</code>    激活deepflame环境</p><p><code>conda create -n deepflame python=3.9</code>  激活一个名字为deepflame的新环境</p><p><code>conda deactivate</code>  退出conda环境</p><h1 id="cantera"><a href="#cantera" class="headerlink" title="cantera"></a>cantera</h1><p><code>ck2yaml --input=C2H4-42s-171r.inp --thermo=C2H4-42s-therm.dat --transport=C2H4-42s-trans.dat</code></p><p>转化机理为yaml格式</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Amrex计算碳烟</title>
    <link href="/2024/10/05/%E4%BD%BF%E7%94%A8Amrex%E8%AE%A1%E7%AE%97%E7%A2%B3%E7%83%9F/"/>
    <url>/2024/10/05/%E4%BD%BF%E7%94%A8Amrex%E8%AE%A1%E7%AE%97%E7%A2%B3%E7%83%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Amrex的安装"><a href="#Amrex的安装" class="headerlink" title="Amrex的安装"></a>Amrex的安装</h1><p>Amrex主要由三个部分构成：PelePhysics PeleLMeX PeleC ,我们这里计算碳烟主要是用到了前两个，PelePhysics主要提供化学计算，而后者提供流体求解器，具体的说明和安装可以参考<a href="https://amrex-combustion.github.io/">AMReX-Combustion: Suite of adaptive mesh reacting flow codes for reacting flows</a></p><h1 id="常见BUG总结"><a href="#常见BUG总结" class="headerlink" title="常见BUG总结"></a>常见BUG总结</h1><p>（1）</p><p> ==============================================================================<br><code>&lt;!--Est. time step - Conv: 2.348325225e-06, divu: 0.0007054938829--&gt;&lt;!--STEP [30000] - Time: 0.1481225918, dt 2.348325225e-06--&gt;&lt;!--0::Assertionamrlev &gt;= 0 &amp;&amp; amrlev &lt; this-&gt;m_num_amr_levels&#39; failed, file &quot;/home/zhangjiaqian/PelePhysics/Submodules/amrex/Src/LinearSolvers/MLMG/AMReX_MLCellLinOp.H&quot;, line 504 !!!--&gt;</code><br><code>&lt;!--SIGABRT--&gt;</code><br>在添加辐射模块的时候，提示遇到断言错误，这是因为mx_level的大小和ref_ratio的数量没有保持一致导致的，如果设置了多层次细化比率，请确保其大小与 <code>amr.max_level</code> 一致。<br><code>amr.max_level       = 2                # maximum level number allowed</code><br><code>amr.ref_ratio       = 2 2            # refinement ratio</code></p><p>同时因为不知道的bug,这里如果直接启动还是会报错，建议先算几步，然后在input里面指定重新计算</p><h1 id="燃烧配置"><a href="#燃烧配置" class="headerlink" title="燃烧配置"></a>燃烧配置</h1><h2 id="1物理建模"><a href="#1物理建模" class="headerlink" title="1物理建模"></a>1物理建模</h2><p>由于Amrex是使用自适应网格技术，它的一个最大的优点就是不用自己画网格，调节粗细。这里采用我们实验室的燃烧器计算图纸进行建模。</p><p><img src="/images/实验室图纸.jpg" alt="燃烧器模型"></p><p>选择项目提供的案例里最相近的模型进行修改，这里我们选择PeleLMeX\Exec\Production\DiffBunsen2D</p><p>案例文件，从文件名上也可以看出这是一个二维扩散本生灯相关的案例。</p><h3 id="1）CMakeLists-txt"><a href="#1）CMakeLists-txt" class="headerlink" title="1）CMakeLists.txt"></a>1）CMakeLists.txt</h3><p>先看看CMakeLists.txt(值得说明的是AMREX为大规模并行计算设计的结构非常好，它使用了编译可执行文件+Input文本的方式进行计算，而不依赖其它相关项，这里后面也会讲)</p><p><code>target_include_directories(pelelmex PUBLIC $&lt;BUILD_INTERFACE:$&#123;CMAKE_CURRENT_LIST_DIR&#125;&gt;)</code></p><p><code>set(PELE_CHEMISTRY_MODEL drm19 PARENT_SCOPE)</code><br><code>set(PELE_EOS_MODEL       Fuego PARENT_SCOPE)</code><br><code>set(PELE_TRANSPORT_MODEL Simple PARENT_SCOPE)</code><br><code>set(PELE_DIM &quot;2&quot; PARENT_SCOPE)</code><br><code>set(PELE_MPI ON PARENT_SCOPE)</code></p><p><code>target_sources(pelelmex</code><br>    <code>PRIVATE</code><br>        <code>pelelmex_prob.cpp</code><br>        <code>pelelmex_prob.H</code><br>        <code>pelelmex_prob_parm.H</code><br>    <code>)</code></p><p>第一行不用管，这是告诉系统寻找相关头文件和执行安装当前目录的</p><p><code>set(PELE_CHEMISTRY_MODEL drm19 PARENT_SCOPE)</code> 使用drm19化学机理，amrex使用不同化学机理需要使用yaml格式文件转化（如果只有标准chemkin格式则需要先用ck2转化为yaml），详细的转化可以参考官网给的教程<a href="https://amrex-combustion.github.io/PelePhysics/Ceptr.html#generating-pele-compatible-mechanisms-for-a-single-chemistry">CEPTR: Chemistry Evaluation for Pele Through Recasting — PelePhysics 2022.10 documentation (amrex-combustion.github.io)</a></p><p>剩下的几行分别代表使用的状态模型（EOS），输运模型，计算维数，并行计算，以及目录下面的一些头文件等</p><h3 id="2）GNUmakefile"><a href="#2）GNUmakefile" class="headerlink" title="2）GNUmakefile"></a>2）GNUmakefile</h3><p>上面的Cmakelist似乎对后面的编译操作影响不大（我一般是两个都改，但是make操作应该是只针对这个文件的，不懂，后面再看）<br>里面的文件也是进行相关的设置，值得注意的是，这里需要指定Pele的目录，如果你不是在案例目录操作则需要对应更改，推荐使用绝对路径</p><p><code>PELE_HOME ?= ../../..</code><br><code>include $(PELE_HOME)/Exec/Make.PeleLMeX</code></p><h3 id="3）pelelmex-Prob-cpp"><a href="#3）pelelmex-Prob-cpp" class="headerlink" title="3）pelelmex_Prob.cpp"></a>3）pelelmex_Prob.cpp</h3><p>这个文件只定义了一个函数，这个函数是用来读取input字典里面的初始条件参数的。</p><p><code>PeleLM::readProbParm()</code></p><p><code>&#123;****</code></p><p><code>&#125;</code></p><h3 id="4）pelelmex-prob-H"><a href="#4）pelelmex-prob-H" class="headerlink" title="4）pelelmex_prob.H"></a>4）pelelmex_prob.H</h3><p>这里具体定义了物理模型<br><em>// Find the zone of the cell to identify the inflow, initial conditions and BC</em></p><p><em>// There are 4 zones : 1 = Fuel inflow ; 2 = Obstacle ; 3 = Oxidizer inflow ; 4</em></p><p><em>// = Air inflow Schema : [ 1 | 2 | 3 | 4 ]</em></p><p>这是一个层流同轴扩散火焰的模型，其中1是燃料出口，2是墙壁，三是氧化剂出口，4是空气出口（这个在我的模型里目前没用到）</p><p>具体代码实现</p><p> <code>const amrex::Real* prob_lo = geomdata.ProbLo();</code></p><p> <code>const amrex::Real* prob_hi = geomdata.ProbHi();</code></p><p> <code>amrex::Real split12 = prob_lo[0] + prob_parm.Xf;</code></p><p> <code>amrex::Real split23 = prob_lo[0] + prob_parm.Xf + prob_parm.Xe;</code></p><p> <code>amrex::Real split34 = prob_lo[0] + prob_parm.Xf + prob_parm.Xe + prob_parm.Xc;</code></p><p>所以如果要更改燃料碰嘴大小等，需要在input里面更改对应的参数</p><p>这里的文件应该是每个网格读取一次，然后根据x的值返回对应zone的标签。接下来的代码包括设置点火，二次函数燃料出口等</p><h3 id="5）pelelmex-prob-parm-H"><a href="#5）pelelmex-prob-parm-H" class="headerlink" title="5）pelelmex_prob_parm.H"></a>5）pelelmex_prob_parm.H</h3><p>设置相关的物理模型参数初始条件</p><p>在input中也能改，且input的优先级要高于这个初始文件</p><h3 id="6）input"><a href="#6）input" class="headerlink" title="6）input"></a>6）input</h3><h4 id="DOMAIN-DEFINITION"><a href="#DOMAIN-DEFINITION" class="headerlink" title="DOMAIN DEFINITION"></a>DOMAIN DEFINITION</h4><p><code>#----------------------DOMAIN DEFINITION------------------------</code><br><code>prob.Xmax = 0.0185 #Maximum size in the x direction</code><br><code>prob.Ymax = 0.037 #Maximum size in the y direction</code><br><code>prob.Zmax = 0.0185 #Maximum size in the z direction</code></p><p>展示不清楚这个和下面有什么区别，先不动</p><p>geometry.is_periodic = 0 0                          # For each dir, 0: non-perio,periodic<br>geometry.coord_sys   = 1                              # 0 =&gt; cart, 1 =&gt; RZ<br>geometry.prob_lo     = 0.0 0.0                   # x_lo y_lo (z_lo)<br>geometry.prob_hi     = 0.0185 0.037             # x_hi y_hi (z_hi)</p><p>第一个设置周期边界条件，第二个设置轴对称模型，第三个设置矩形的对角</p><h4 id="BC-FLAGS"><a href="#BC-FLAGS" class="headerlink" title="BC FLAGS"></a>BC FLAGS</h4><p>Interior, Inflow, Outflow, Symmetry,</p><p>SlipWallAdiab, NoSlipWallAdiab, SlipWallIsotherm, NoSlipWallIsotherm</p><p>peleLM.lo_bc = Symmetry      Inflow<br>peleLM.hi_bc = SlipWallAdiab Outflow<br>设置对应的边界条件，不用改动</p><h4 id="AMR-CONTROL"><a href="#AMR-CONTROL" class="headerlink" title="AMR CONTROL"></a>AMR CONTROL</h4><p>amr.n_cell          = 128 256 32        # Level 0 number of cells in each direction<br>amr.v               = 1                # AMR verbose  输出日志的详细程度<br>amr.max_level       = 1                # maximum level number allowed  最大细化等级，0代表不使用AMR<br>amr.ref_ratio       = 2 2 2 2          # refinement ratio  对应每个方向上细化率，2代表细化一倍，第一个2代表从0level -1level 的细化倍率，以此类推<br>amr.regrid_int      = 2                # how often to regrid<br>amr.n_error_buf     = 4 2 2 2          # number of buffer cells in error est<br>amr.grid_eff        = 0.7              # what constitutes an efficient grid<br>amr.blocking_factor = 16               # block factor in grid generation (min box size)<br>amr.max_grid_size   = 64              # max box size</p><p>意思见注释</p><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h4><h1 id="—————————————-Problem-———————————————"><a href="#—————————————-Problem-———————————————" class="headerlink" title="—————————————- Problem ———————————————-"></a>—————————————- Problem ———————————————-</h1><p>prob.Xf = 0.0011    # Radius of the fuel pipe<br>prob.Xe = 0.0001    # Thickness of the extruded tube<br>prob.Xc = 0.0113    # Size of the oxidizer fuel</p><p>prob.Yin = 0.003  # Height of the inflow entrance at t=0s<br>prob.V_fu = 0.15  # Speed of the fuel in inflow<br>prob.V_ox = 0.031 # Speed of the oxidizer in inflow<br>prob.V_air = 0.0  # Speed of the air flow around the burner<br>prob.T_fu = 300   # Temperature of the fuel<br>prob.T_ox = 300   # Temperature of the oxidizer<br>prob.T_air = 300  # Temperature of the air<br>prob.T_obst = 450 # Temperature of the fuel pipe (=obstacle)</p><p>prob.do_ignition = 1    # Do you want to do ignition ?<br>prob.ign_rad = 0.001    # Size of the ignition blob<br>prob.ign_T = 1900       # Temperature inside the ignition blob</p><p>prob.P_mean = 100000.0 # Ambient pressure in the chamber</p><p>prob.dilution = 0.7 # Proportion of CH4 in the fuel mix. Ch4 is diluted in N2</p><p>见字面意思，注意这里dilution0.7代表燃料的质量分数</p><h4 id="PeleLM-CONTROL"><a href="#PeleLM-CONTROL" class="headerlink" title="PeleLM CONTROL"></a>PeleLM CONTROL</h4><h1 id="————————————-PeleLM-CONTROL——————————————"><a href="#————————————-PeleLM-CONTROL——————————————" class="headerlink" title="————————————-PeleLM CONTROL——————————————"></a>————————————-PeleLM CONTROL——————————————</h1><p>peleLM.gravity = 0.0 -9.81 0.0</p><p>peleLM.v = 2   输出日志等级<br>peleLM.incompressible = 0    0代表可压缩流体<br>peleLM.rho = 1.17<br>peleLM.mu = 0.0<br>peleLM.use_wbar = 1    指定是否使用分子量平均，<code>1</code> 表示开启。<br>peleLM.sdc_iterMax = 2<br>peleLM.floor_species = 0<br>peleLM.num_init_iter = 3<br>peleLM.advection_scheme = “Godunov_PLM”  指定对流的数值方案，这里使用 “Godunov_PLM”（Piecewise Linear Method），通常是一种高分辨率方案<br>peleLM.do_temporals = 1 # use to calculate the integrals<br>peleLM.do_mass_balance = 1    否进行质量守恒计算，<code>1</code> 表示启用。</p><h1 id="peleLM-deltaT-verbose-1-控制时间步调节信息输出的详细程度。"><a href="#peleLM-deltaT-verbose-1-控制时间步调节信息输出的详细程度。" class="headerlink" title="peleLM.deltaT_verbose = 1     控制时间步调节信息输出的详细程度。"></a>peleLM.deltaT_verbose = 1     控制时间步调节信息输出的详细程度。</h1><p>peleLM.deltaT_iterMax = 15         调整时间步的最大迭代次数。</p><h4 id="AMR-CONTROL-1"><a href="#AMR-CONTROL-1" class="headerlink" title="AMR CONTROL"></a>AMR CONTROL</h4><h1 id="amr-restart-chk05000"><a href="#amr-restart-chk05000" class="headerlink" title="amr.restart = chk05000"></a>amr.restart = chk05000</h1><p>amr.check_int = 100<br>amr.plot_int = 100<br>amr.max_step = 100<br>amr.dt_shrink = 0.01    时间步缩减因子，初始时用较小的时间步以保证稳定性。</p><h1 id="amr-stop-time-0-001"><a href="#amr-stop-time-0-001" class="headerlink" title="amr.stop_time = 0.001"></a>amr.stop_time = 0.001</h1><p>amr.init_dt = 0.000001  初始迭代次数，在时间积分开始前进行的初始化迭代次数。<br>amr.cfl = 0.05<br>amr.derive_plot_vars = avg_pressure mag_vort mass_fractions</p><p>peleLM.chem_integrator = “ReactorCvode”        使用 CVODE 进行化学积分<br>peleLM.use_typ_vals_chem = 1          # Use species/temp typical values in CVODE<br>ode.rtol = 1.0e-7                     # Relative tolerance of the chemical solve<br>ode.atol = 1.0e-6                     # Absolute tolerance factor applied on typical values<br>cvode.solve_type = denseAJ_direct     # CVODE Linear solve type (for Newton direction)<br>cvode.max_order  = 4                  # CVODE max BDF order. </p><h4 id="REFINEMENT-CONTROL"><a href="#REFINEMENT-CONTROL" class="headerlink" title="REFINEMENT CONTROL"></a>REFINEMENT CONTROL</h4><h1 id="——————————REFINEMENT-CONTROL————————————"><a href="#——————————REFINEMENT-CONTROL————————————" class="headerlink" title="——————————REFINEMENT CONTROL————————————"></a>——————————REFINEMENT CONTROL————————————</h1><p>amr.refinement_indicators = HR    <code>HR</code>（Heat Release，即热释放率) 根据热释率进行细化<br>amr.HR.max_level     = 1    设置 <code>HR</code> 指标的最大细化层级为 <code>1</code>，这意味着网格在满足该细化条件的区域最多可以细化到 Level 1。<br>amr.HR.value_greater = 5e7      如果某区域的热释放率大于 <code>5e7</code>，则触发网格细化。<br>amr.HR.field_name    = HeatRelease    指定用于细化条件的字段名称为 <code>HeatRelease</code>。这通常是由求解器计算出的一个场变量，代表燃烧过程中热释放的速率。</p><h1 id="amr-refinement-indicators-magVort-涡量幅度（mag-vort）来细化网格。"><a href="#amr-refinement-indicators-magVort-涡量幅度（mag-vort）来细化网格。" class="headerlink" title="amr.refinement_indicators = magVort      涡量幅度（mag_vort）来细化网格。"></a>amr.refinement_indicators = magVort      涡量幅度（<code>mag_vort</code>）来细化网格。</h1><h1 id="amr-magVort-max-level-1"><a href="#amr-magVort-max-level-1" class="headerlink" title="amr.magVort.max_level     = 1"></a>amr.magVort.max_level     = 1</h1><h1 id="amr-magVort-value-greater-500-0"><a href="#amr-magVort-value-greater-500-0" class="headerlink" title="amr.magVort.value_greater = 500.0"></a>amr.magVort.value_greater = 500.0</h1><h1 id="amr-magVort-field-name-mag-vort"><a href="#amr-magVort-field-name-mag-vort" class="headerlink" title="amr.magVort.field_name    = mag_vort"></a>amr.magVort.field_name    = mag_vort</h1><h1 id="amr-refinement-indicators-boxNoz-这个指标用于根据几何区域（box）的范围来细化网格，通常用于细化某些特定物理区域，例如喷嘴。"><a href="#amr-refinement-indicators-boxNoz-这个指标用于根据几何区域（box）的范围来细化网格，通常用于细化某些特定物理区域，例如喷嘴。" class="headerlink" title="amr.refinement_indicators = boxNoz    这个指标用于根据几何区域（box）的范围来细化网格，通常用于细化某些特定物理区域，例如喷嘴。"></a>amr.refinement_indicators = boxNoz    这个指标用于根据几何区域（box）的范围来细化网格，通常用于细化某些特定物理区域，例如喷嘴。</h1><h1 id="amr-boxNoz-max-level-3-网格细化最大层级为-3，比其他指标的层级更高。"><a href="#amr-boxNoz-max-level-3-网格细化最大层级为-3，比其他指标的层级更高。" class="headerlink" title="amr.boxNoz.max_level     = 3    网格细化最大层级为 3，比其他指标的层级更高。"></a>amr.boxNoz.max_level     = 3    网格细化最大层级为 <code>3</code>，比其他指标的层级更高。</h1><h1 id="amr-boxNoz-in-box-lo-0-000-0-0-指定用于细化的几何区域，范围在-in-box-lo-和-in-box-hi-之间。这里区域在二维平面上，限定了细化的空间范围。"><a href="#amr-boxNoz-in-box-lo-0-000-0-0-指定用于细化的几何区域，范围在-in-box-lo-和-in-box-hi-之间。这里区域在二维平面上，限定了细化的空间范围。" class="headerlink" title="amr.boxNoz.in_box_lo = 0.000 0.0    指定用于细化的几何区域，范围在 in_box_lo 和 in_box_hi 之间。这里区域在二维平面上，限定了细化的空间范围。"></a>amr.boxNoz.in_box_lo = 0.000 0.0    指定用于细化的几何区域，范围在 <code>in_box_lo</code> 和 <code>in_box_hi</code> 之间。这里区域在二维平面上，限定了细化的空间范围。</h1><h1 id="amr-boxNoz-in-box-hi-0-0045-0-0045"><a href="#amr-boxNoz-in-box-hi-0-0045-0-0045" class="headerlink" title="amr.boxNoz.in_box_hi = 0.0045 0.0045"></a>amr.boxNoz.in_box_hi = 0.0045 0.0045</h1><h1 id="amrex-fpe-trap-invalid-1-启用对非法浮点操作的捕获，例如计算未定义的操作（如-NaN）。"><a href="#amrex-fpe-trap-invalid-1-启用对非法浮点操作的捕获，例如计算未定义的操作（如-NaN）。" class="headerlink" title="amrex.fpe_trap_invalid = 1   启用对非法浮点操作的捕获，例如计算未定义的操作（如 NaN）。"></a>amrex.fpe_trap_invalid = 1   启用对非法浮点操作的捕获，例如计算未定义的操作（如 <code>NaN</code>）。</h1><h1 id="amrex-fpe-trap-zero-1-启用对除零操作的捕获，如果浮点运算中发生了除零错误，将触发异常。"><a href="#amrex-fpe-trap-zero-1-启用对除零操作的捕获，如果浮点运算中发生了除零错误，将触发异常。" class="headerlink" title="amrex.fpe_trap_zero = 1   启用对除零操作的捕获，如果浮点运算中发生了除零错误，将触发异常。"></a>amrex.fpe_trap_zero = 1   启用对除零操作的捕获，如果浮点运算中发生了除零错误，将触发异常。</h1><h1 id="amrex-fpe-trap-overflow-1-启用对浮点运算溢出的捕获，当浮点数超过最大范围导致溢出时触发异常。"><a href="#amrex-fpe-trap-overflow-1-启用对浮点运算溢出的捕获，当浮点数超过最大范围导致溢出时触发异常。" class="headerlink" title="amrex.fpe_trap_overflow = 1      启用对浮点运算溢出的捕获，当浮点数超过最大范围导致溢出时触发异常。"></a>amrex.fpe_trap_overflow = 1      启用对浮点运算溢出的捕获，当浮点数超过最大范围导致溢出时触发异常。</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>个人博客搭建指南</title>
    <link href="/2024/10/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
    <url>/2024/10/04/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>我的所有网站博客配置都是跟着这个文章写的<br><a href="https://blog.csdn.net/yaorongke/article/details/119089190">GitHub Pages + Hexo搭建个人博客网站，史上最全教程_hexo博客-CSDN博客</a></p><p>一些常见的运行命令：<br><code>hexo g -d</code></p><p>部署到GitHub上（要提前配置gitHub相关的信息）</p><p><code>hexo s</code></p><p>这两个用来本地启动</p><p><code>hexo new post 个人博客搭建指南</code><br>这个指令用来新建post文</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2024/10/02/hello-world/"/>
    <url>/2024/10/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
